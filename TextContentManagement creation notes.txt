Rewritten with a Primary Constructor

public class TextContent(string title, string author, string serialNumber, int year) 
{
    // Initialize properties directly using primary constructor parameters
    public string Title { get; set; } = title;
    public string Author { get; set; } = author;
    public string SerialNumber { get; set; } = serialNumber;
    public int Year { get; set; } = year;
    public bool Availability { get; set; } = true; // Default value
}

Key Changes

    Constructor parameters are declared in the class header:
    csharp

    public class TextContent(string title, string author, ...)

    Properties are initialized directly using = title (no explicit constructor body).

Why Use This?

    Less boilerplate: No need for a separate { ... } constructor block.

    Cleaner code: Parameters and property assignments are consolidated.

When to Avoid Primary Constructors

    If your constructor has complex logic (e.g., validation, calculations).

    Example (stick with traditional for validation):
    csharp

    public TextContent(string title, ...) 
    {
        if (string.IsNullOrEmpty(title)) 
            throw new ArgumentException("Title required!");
        Title = title;
        // ...
    }



Asked because the IDE (Visual Studio 2022) is suggesting a code style improvement to adopt the newer, cleaner syntax (but how is it clean if there is more text?).


-----

Why use each?


1. Primary Constructors vs. Validation

    Primary constructors are designed for simple initialization.

    Validation requires conditional checks (e.g., if statements), which cannot be done directly in primary constructors.

    Workaround: Use a traditional constructor for validation, or combine primary constructors with property initializers (for basic validation).

2. When to Use Each
	Scenario	Primary Constructor	Traditional Constructor
	Simple initialization	✅ Yes	✅ Yes
	Complex validation (e.g., if checks)	❌ No	✅ Yes
	Default values	✅ Yes	✅ Yes

3. Practical Examples
	a) Primary Constructor (No Validation)

Simple assignment only:

	public class TextContent(string title, string author, string serialNumber, int year)
	{
		public string Title { get; } = title; // Direct assignment
		public string Author { get; } = author;
		public string SerialNumber { get; } = serialNumber;
		public int Year { get; } = year;
		public bool Availability { get; } = true;
	}

    No validation: If title is null or year is invalid, the object will still be created (problems if mistaking or corrupting).

b) Primary Constructor + Property Initializers (Basic Validation)

Add simple validation during property initialization:

	public class TextContent(string title, string author, string serialNumber, int year)
	{
		public string Title { get; } = title ?? throw new ArgumentNullException(nameof(title));
		public string Author { get; } = !string.IsNullOrWhiteSpace(author) 
			? author 
			: throw new ArgumentException("Author cannot be empty.");
		public int Year { get; } = year is >= 1800 and <= DateTime.Now.Year + 1 
			? year 
			: throw new ArgumentException("Invalid year.");
		// ... other properties
	}

		Works for simple checks: Uses ternary operators or throw in property initializers.

		Limitation: Validation logic is split across properties (less centralized).

c) Traditional Constructor (Full Validation)

Best for complex validation:

	public class TextContent
	{
		public string Title { get; }
		public string Author { get; }
		public int Year { get; }

		public TextContent(string title, string author, int year)
		{
			// Centralized validation
			if (string.IsNullOrWhiteSpace(title))
				throw new ArgumentException("Title cannot be empty.");
			if (year < 1800)
				throw new ArgumentException("Year must be ≥ 1800.");

			Title = title;
			Author = author;
			Year = year;
		}
	}

    Full control: All validation happens in one place - THE CHOICE FOR TextContentManagement

4. Key Takeaways

    Primary Constructors:

        Use for simple assignments (no if/throw logic).

        Add basic validation via property initializers (limited to single-line checks).

        Example:
        

			public string Title { get; } = title ?? throw new ArgumentNullException(nameof(title));

		Traditional Constructors:

			Use when you need multi-step validation (e.g., checking multiple conditions).

			Keep validation logic centralized.

5. Recommendation for Your Project

Given your TextContent class needs validation (e.g., non-empty Title, valid Year), use a traditional constructor:


	public class TextContent
	{
		public string Title { get; }
		public string Author { get; }
		public string SerialNumber { get; }
		public int Year { get; }
		public bool Availability { get; }

		public TextContent(string title, string author, string serialNumber, int year)
		{
			// Validate Title
			if (string.IsNullOrWhiteSpace(title))
				throw new ArgumentException("Title is required.");
        
			// Validate Year
			if (year < 1800 || year > DateTime.Now.Year + 1)
				throw new ArgumentException("Invalid year.");
        
			// Validate SerialNumber (example)
			if (string.IsNullOrWhiteSpace(serialNumber) || !serialNumber.StartsWith("SN-"))
				throw new ArgumentException("Serial number must start with 'SN-'.");

			// Assign if valid
			Title = title;
			Author = author;
			SerialNumber = serialNumber;
			Year = year;
			Availability = true;
		}
	}

6. Why This Works

    Centralized validation: All checks are in one place.

    Safer objects: Ensures TextContent instances are valid from creation.

    Clear error messages: Throws exceptions with meaningful descriptions.


Initialization is setting value to a property, variable, or object when it is created. The Traditional Constructor does that here. It is needed because:

 

   a) Prevents null/garbage values: Without initialization, properties like Title would default to null, causing errors if used.

   b) Ensures validity: Objects start with meaningful data (e.g., a book can’t exist without a title).

   c) Avoids crashes: Code like Console.WriteLine(book.Title) would crash if Title is null.

4. How Initialization Works & Declaration vs. Initialization



    Declaration: Creating a variable/property.


public string Title; // Declared but not initialized (Title = null)

Initialization: Giving it a value.

Title = "C# Basics"; // Initialized with a valid value




-----------------------------------------------------------

What are variables, objects, and properties?



1. Variable

Definition:
A named "container" that holds a value or reference to an object.

	Example in Your Code:

	TextContent book = new TextContent("C# Basics", "Jane Doe", "SN-123", 2023);

		book is a variable that holds a reference to a TextContent object.

		"C# Basics" is a variable of type string holding the title.

Key Points:

    Variables can hold primitive values (int, string) or objects.

    They exist in methods, constructors, or as class fields.


2. Object

Definition:
An instance of a class created at runtime. It’s a concrete "thing" built from the class blueprint.


	Example in Your Code:


	new TextContent("C# Basics", "Jane Doe", "SN-123", 2023);

		This creates an object of type TextContent with the specified properties.

		The book variable points to this object.

Key Points:

    Objects have state (data stored in properties) and behavior (methods, though you haven’t added methods yet).

    Created using the new keyword.

3. Property

Definition:
A class member that encapsulates data (like a variable) but provides controlled access via get/set.


Example in Your Code:


	public class TextContent
	{
		public string Title { get; set; } // Property
		public int Year { get; set; }     // Property
	}

    Title and Year are properties of the TextContent class.

    They define the data your TextContent objects hold (e.g., book.Title = "C# Basics";).

Key Points:

    Properties often map to variables (e.g., Title might use a hidden string _title field).

    They enforce rules (e.g., validation in set).


Relationship in Your Project
Term			Example									Role
Variable		TextContent book;						Holds a reference to a TextContent object.
Object			new TextContent(...)					The actual data (e.g., a book’s title, year) stored in memory.
Property		public string Title { get; set; }		Defines the data fields of the object (e.g., book.Title).


Practical Scenario

When you write:

TextContent book = new TextContent("C# Basics", "Jane Doe", "SN-123", 2023);

    Variable: book (holds the reference to the object).

    Object: The TextContent instance created in memory with the given title, author, etc.

    Properties: Title, Author, Year, etc., which store the object’s data.

Why This Matters

    Variables let you interact with objects.

    Objects store your program’s data.

    Properties define what data an object can hold and how it’s accessed.
	

---
Runtime - when a "compiled" program is operating.
|| (Shift + \) - add conditions to if statement.

parse (ENG) - to analyze, understand, to translate into a computational lingustic coprehension.



IMPORTANT!!! WHY NEED THE CONTSTRUCTOR!!!

	1. Role of the Constructor

	The constructor initializes the object’s properties when it’s created. Parameters (e.g., title, year) are used to set the initial values of the properties.

		Example:

		public TextContent(string title, int year)  
		{  
			Title = title; // Assigns parameter "title" to the "Title" property  
			Year = year;  
		}  

	Without a constructor, you can still create objects, but you’ll need to:

		Use default values (e.g., public string Title { get; set; } = "Untitled";).

		Set properties manually after creation:

	TextContent book = new TextContent();  
	book.Title = "C# Basics"; // Requires a public setter  
	
		4. If You Remove the Constructor

Without a constructor:

    Default parameterless constructor is used.

    Properties start with default values (null, 0, etc.).

    No validation occurs at object creation. - THE KEY.

    Properties can still be modified (if set; exists).

---
3. Parameters vs. Properties

    Parameters: Inputs passed to the constructor (e.g., title, year).

    Properties: Data fields of the object (e.g., Title, Year).
	


---
ArgumentNullException - for null-specific errors. 
ArgumentException - for empty Strings or invalid formats.





